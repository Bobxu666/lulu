<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态Padding可视化演示</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            min-height: 100vh;
        }
        
        .main-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.2em;
        }
        
        .controls-section {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 2px solid #74b9ff;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-weight: bold;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .value-display {
            background: #3498db;
            color: white;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.9em;
            min-width: 30px;
            text-align: center;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 5px;
            outline: none;
        }
        
        .calculation-display {
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            line-height: 1.6;
        }
        
        .visualization-section {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            gap: 30px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .tensor-container {
            background: #f8f9ff;
            border: 2px solid #74b9ff;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            min-width: 300px;
        }
        
        .tensor-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .tensor-canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: white;
            margin: 15px 0;
        }
        
        .tensor-info {
            background: white;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
        }
        
        .arrow-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 20px;
        }
        
        .arrow {
            font-size: 3em;
            color: #e74c3c;
            font-weight: bold;
        }
        
        .padding-legend {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .legend-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 10px;
        }
        
        .legend-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        
        .step-by-step {
            background: #e8f5e8;
            border: 2px solid #27ae60;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .step {
            margin: 15px 0;
            padding: 10px;
            background: white;
            border-radius: 8px;
        }
        
        .step-number {
            display: inline-block;
            background: #27ae60;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            margin-right: 10px;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .visualization-section {
                flex-direction: column;
                align-items: center;
            }
            
            .arrow {
                transform: rotate(90deg);
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>🔧 动态Padding到目标尺寸可视化</h1>
        
        <div class="controls-section">
            <h3>📊 参数调整</h3>
            <div class="controls-grid">
                <div class="control-group">
                    <label>原始高度 (H): <span class="value-display" id="orig-h-value">120</span></label>
                    <input type="range" id="orig-h" min="80" max="200" value="120">
                </div>
                <div class="control-group">
                    <label>原始宽度 (W): <span class="value-display" id="orig-w-value">160</span></label>
                    <input type="range" id="orig-w" min="100" max="250" value="160">
                </div>
                <div class="control-group">
                    <label>目标高度 (max_h): <span class="value-display" id="max-h-value">200</span></label>
                    <input type="range" id="max-h" min="120" max="300" value="200">
                </div>
                <div class="control-group">
                    <label>目标宽度 (max_w): <span class="value-display" id="max-w-value">240</span></label>
                    <input type="range" id="max-w" min="160" max="350" value="240">
                </div>
            </div>
            
            <div class="calculation-display" id="calculations"></div>
        </div>
        
        <div class="padding-legend">
            <div class="legend-title">🎨 颜色图例</div>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>原始数据</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>左侧填充</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #27ae60;"></div>
                    <span>右侧填充</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>底部填充</span>
                </div>
            </div>
        </div>
        
        <div class="visualization-section">
            <div class="tensor-container">
                <div class="tensor-title">📥 原始张量</div>
                <canvas id="original-canvas" class="tensor-canvas" width="300" height="200"></canvas>
                <div class="tensor-info" id="original-info"></div>
            </div>
            
            <div class="arrow-container">
                <div class="arrow">➡️</div>
            </div>
            
            <div class="tensor-container">
                <div class="tensor-title">📤 填充后张量</div>
                <canvas id="padded-canvas" class="tensor-canvas" width="300" height="200"></canvas>
                <div class="tensor-info" id="padded-info"></div>
            </div>
        </div>
        
        <div class="step-by-step">
            <h3>🔍 逐步分析</h3>
            <div class="step">
                <span class="step-number">1</span>
                <strong>计算高度填充：</strong> <code>h_pad = max_h - H</code><br>
                只在底部填充，保持图像在顶部对齐
            </div>
            <div class="step">
                <span class="step-number">2</span>
                <strong>计算左侧填充：</strong> <code>w_pad_left = (max_w - W) // 2</code><br>
                整除运算，保证居中对齐
            </div>
            <div class="step">
                <span class="step-number">3</span>
                <strong>计算右侧填充：</strong> <code>w_pad_right = max_w - W - w_pad_left</code><br>
                补齐剩余部分，处理奇数宽度差
            </div>
            <div class="step">
                <span class="step-number">4</span>
                <strong>应用填充：</strong> <code>transforms.Pad((left, top, right, bottom))</code><br>
                参数顺序：左、上、右、下，这里top=0
            </div>
        </div>
    </div>
    
    <script>
        // 获取所有控件
        const controls = {
            origH: document.getElementById('orig-h'),
            origW: document.getElementById('orig-w'),
            maxH: document.getElementById('max-h'),
            maxW: document.getElementById('max-w')
        };
        
        const valueDisplays = {
            origH: document.getElementById('orig-h-value'),
            origW: document.getElementById('orig-w-value'),
            maxH: document.getElementById('max-h-value'),
            maxW: document.getElementById('max-w-value')
        };
        
        const originalCanvas = document.getElementById('original-canvas');
        const paddedCanvas = document.getElementById('padded-canvas');
        const originalCtx = originalCanvas.getContext('2d');
        const paddedCtx = paddedCanvas.getContext('2d');
        
        function updateDisplay() {
            // 获取当前值
            const origH = parseInt(controls.origH.value);
            const origW = parseInt(controls.origW.value);
            const maxH = parseInt(controls.maxH.value);
            const maxW = parseInt(controls.maxW.value);
            
            // 更新显示值
            valueDisplays.origH.textContent = origH;
            valueDisplays.origW.textContent = origW;
            valueDisplays.maxH.textContent = maxH;
            valueDisplays.maxW.textContent = maxW;
            
            // 计算填充
            const hPad = Math.max(0, maxH - origH);
            const wPadLeft = Math.max(0, Math.floor((maxW - origW) / 2));
            const wPadRight = Math.max(0, maxW - origW - wPadLeft);
            
            // 显示计算过程
            const calculations = document.getElementById('calculations');
            calculations.innerHTML = `
<strong>📐 填充计算：</strong><br>
h_pad = max_h - proj_tensor.size(1) = ${maxH} - ${origH} = <span style="color: #f39c12;">${hPad}</span><br>
w_pad_left = (max_w - proj_tensor.size(2)) // 2 = (${maxW} - ${origW}) // 2 = <span style="color: #e74c3c;">${wPadLeft}</span><br>
w_pad_right = max_w - proj_tensor.size(2) - w_pad_left = ${maxW} - ${origW} - ${wPadLeft} = <span style="color: #27ae60;">${wPadRight}</span><br><br>
<strong>🔧 PyTorch填充参数：</strong><br>
transforms.Pad((<span style="color: #e74c3c;">${wPadLeft}</span>, <span style="color: #9b59b6;">0</span>, <span style="color: #27ae60;">${wPadRight}</span>, <span style="color: #f39c12;">${hPad}</span>))  # (left, top, right, bottom)
            `;
            
            // 绘制原始张量
            drawOriginalTensor(origH, origW);
            
            // 绘制填充后张量
            drawPaddedTensor(origH, origW, maxH, maxW, wPadLeft, wPadRight, hPad);
            
            // 更新信息显示
            document.getElementById('original-info').innerHTML = `
                <strong>尺寸:</strong> (C, ${origH}, ${origW})<br>
                <strong>总像素:</strong> ${origH * origW}
            `;
            
            document.getElementById('padded-info').innerHTML = `
                <strong>尺寸:</strong> (C, ${maxH}, ${maxW})<br>
                <strong>总像素:</strong> ${maxH * maxW}<br>
                <strong>填充像素:</strong> ${maxH * maxW - origH * origW}
            `;
        }
        
        function drawOriginalTensor(h, w) {
            originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            
            const scale = Math.min(250 / w, 180 / h);
            const drawW = w * scale;
            const drawH = h * scale;
            const offsetX = (originalCanvas.width - drawW) / 2;
            const offsetY = (originalCanvas.height - drawH) / 2;
            
            // 绘制原始数据
            originalCtx.fillStyle = '#3498db';
            originalCtx.fillRect(offsetX, offsetY, drawW, drawH);
            originalCtx.strokeStyle = '#2980b9';
            originalCtx.lineWidth = 2;
            originalCtx.strokeRect(offsetX, offsetY, drawW, drawH);
            
            // 添加网格
            originalCtx.strokeStyle = '#2980b9';
            originalCtx.lineWidth = 1;
            const cellW = drawW / Math.min(w, 20);
            const cellH = drawH / Math.min(h, 20);
            
            for (let i = 0; i <= Math.min(w, 20); i++) {
                originalCtx.beginPath();
                originalCtx.moveTo(offsetX + i * cellW, offsetY);
                originalCtx.lineTo(offsetX + i * cellW, offsetY + drawH);
                originalCtx.stroke();
            }
            
            for (let i = 0; i <= Math.min(h, 20); i++) {
                originalCtx.beginPath();
                originalCtx.moveTo(offsetX, offsetY + i * cellH);
                originalCtx.lineTo(offsetX + drawW, offsetY + i * cellH);
                originalCtx.stroke();
            }
            
            // 添加尺寸标注
            originalCtx.fillStyle = '#2c3e50';
            originalCtx.font = 'bold 14px Arial';
            originalCtx.textAlign = 'center';
            originalCtx.fillText(`${h} × ${w}`, originalCanvas.width / 2, offsetY + drawH + 20);
        }
        
        function drawPaddedTensor(origH, origW, maxH, maxW, wPadLeft, wPadRight, hPad) {
            paddedCtx.clearRect(0, 0, paddedCanvas.width, paddedCanvas.height);
            
            const scale = Math.min(250 / maxW, 180 / maxH);
            const totalDrawW = maxW * scale;
            const totalDrawH = maxH * scale;
            const offsetX = (paddedCanvas.width - totalDrawW) / 2;
            const offsetY = (paddedCanvas.height - totalDrawH) / 2;
            
            const origDrawW = origW * scale;
            const origDrawH = origH * scale;
            const leftPadDrawW = wPadLeft * scale;
            const rightPadDrawW = wPadRight * scale;
            const bottomPadDrawH = hPad * scale;
            
            // 绘制左侧填充
            if (wPadLeft > 0) {
                paddedCtx.fillStyle = '#e74c3c';
                paddedCtx.fillRect(offsetX, offsetY, leftPadDrawW, origDrawH);
            }
            
            // 绘制原始数据
            paddedCtx.fillStyle = '#3498db';
            paddedCtx.fillRect(offsetX + leftPadDrawW, offsetY, origDrawW, origDrawH);
            
            // 绘制右侧填充
            if (wPadRight > 0) {
                paddedCtx.fillStyle = '#27ae60';
                paddedCtx.fillRect(offsetX + leftPadDrawW + origDrawW, offsetY, rightPadDrawW, origDrawH);
            }
            
            // 绘制底部填充
            if (hPad > 0) {
                paddedCtx.fillStyle = '#f39c12';
                paddedCtx.fillRect(offsetX, offsetY + origDrawH, totalDrawW, bottomPadDrawH);
            }
            
            // 绘制边框
            paddedCtx.strokeStyle = '#2c3e50';
            paddedCtx.lineWidth = 2;
            paddedCtx.strokeRect(offsetX, offsetY, totalDrawW, totalDrawH);
            
            // 绘制分割线
            if (wPadLeft > 0) {
                paddedCtx.strokeStyle = '#c0392b';
                paddedCtx.lineWidth = 1;
                paddedCtx.beginPath();
                paddedCtx.moveTo(offsetX + leftPadDrawW, offsetY);
                paddedCtx.lineTo(offsetX + leftPadDrawW, offsetY + origDrawH);
                paddedCtx.stroke();
            }
            
            if (wPadRight > 0) {
                paddedCtx.strokeStyle = '#1e8449';
                paddedCtx.lineWidth = 1;
                paddedCtx.beginPath();
                paddedCtx.moveTo(offsetX + leftPadDrawW + origDrawW, offsetY);
                paddedCtx.lineTo(offsetX + leftPadDrawW + origDrawW, offsetY + origDrawH);
                paddedCtx.stroke();
            }
            
            if (hPad > 0) {
                paddedCtx.strokeStyle = '#d68910';
                paddedCtx.lineWidth = 1;
                paddedCtx.beginPath();
                paddedCtx.moveTo(offsetX, offsetY + origDrawH);
                paddedCtx.lineTo(offsetX + totalDrawW, offsetY + origDrawH);
                paddedCtx.stroke();
            }
            
            // 添加尺寸标注
            paddedCtx.fillStyle = '#2c3e50';
            paddedCtx.font = 'bold 14px Arial';
            paddedCtx.textAlign = 'center';
            paddedCtx.fillText(`${maxH} × ${maxW}`, paddedCanvas.width / 2, offsetY + totalDrawH + 20);
            
            // 添加填充尺寸标注
            if (wPadLeft > 0) {
                paddedCtx.font = '10px Arial';
                paddedCtx.fillStyle = '#c0392b';
                paddedCtx.fillText(wPadLeft, offsetX + leftPadDrawW/2, offsetY + origDrawH/2);
            }
            
            if (wPadRight > 0) {
                paddedCtx.font = '10px Arial';
                paddedCtx.fillStyle = '#1e8449';
                paddedCtx.fillText(wPadRight, offsetX + leftPadDrawW + origDrawW + rightPadDrawW/2, offsetY + origDrawH/2);
            }
            
            if (hPad > 0) {
                paddedCtx.font = '10px Arial';
                paddedCtx.fillStyle = '#d68910';
                paddedCtx.fillText(hPad, offsetX + totalDrawW/2, offsetY + origDrawH + bottomPadDrawH/2);
            }
        }
        
        // 添加事件监听器
        Object.values(controls).forEach(control => {
            control.addEventListener('input', updateDisplay);
        });
        
        // 初始化显示
        updateDisplay();
    </script>
</body>
</html>